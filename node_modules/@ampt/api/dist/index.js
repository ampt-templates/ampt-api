import { createRequire as topLevelCreateRequire } from 'module'
const require = topLevelCreateRequire(import.meta.url)

// ../../lib/tree-router/util.ts
function findWildcard(path) {
  let catchall = false;
  for (let i = 0; i < path.length; i++) {
    const c = path[i];
    if (c !== ":") {
      continue;
    }
    let valid = true;
    const remaining = path.slice(i + 1);
    let end = 0;
    while (end < remaining.length) {
      const char = remaining[end];
      if (char === "/") {
        break;
      }
      if (char === ":") {
        valid = false;
      }
      end++;
    }
    catchall = path[i + end] === "*";
    return {
      wildcard: path.slice(i, i + end + 1),
      catchall,
      i,
      valid
    };
  }
  return {
    wildcard: "",
    i: -1,
    valid: false
  };
}

// ../../lib/tree-router/tree.ts
function longestCommonPrefix(a, b) {
  let i = 0;
  const max = Math.min(a.length, b.length);
  while (i < max && a[i] === b[i]) {
    i++;
  }
  return i;
}
var Node = class {
  path;
  wildChild;
  type;
  indices;
  children;
  handle;
  priority;
  constructor(path = "", wildChild = false, type = 0 /* STATIC */, indices = "", children = [], handle = null, priority = 0) {
    this.path = path;
    this.wildChild = wildChild;
    this.type = type;
    this.indices = indices;
    this.children = children;
    this.handle = handle;
    this.priority = priority;
  }
  addPriority(pos) {
    const children = this.children;
    children[pos].priority++;
    const prio = children[pos].priority;
    let newPos = pos;
    while (newPos > 0 && children[newPos - 1].priority < prio) {
      const temp = children[newPos];
      children[newPos] = children[newPos - 1];
      children[newPos - 1] = temp;
      newPos--;
    }
    if (newPos !== pos) {
      this.indices = this.indices.slice(0, newPos) + this.indices[pos] + this.indices.slice(newPos, pos) + this.indices.slice(pos + 1);
    }
    return newPos;
  }
  addRoute(path, handle) {
    let n = this;
    let fullPath = path;
    n.priority++;
    if (n.path.length === 0 && n.children.length === 0) {
      n.insertChild(path, fullPath, handle);
      n.type = 1 /* ROOT */;
      return;
    }
    walk:
      for (; ; ) {
        let i = longestCommonPrefix(path, n.path);
        if (i < n.path.length) {
          const child = new Node(
            n.path.slice(i),
            n.wildChild,
            0 /* STATIC */,
            n.indices,
            n.children,
            n.handle,
            n.priority - 1
          );
          n.children = [child];
          n.indices = n.path[i];
          n.path = path.slice(0, i);
          n.handle = null;
          n.wildChild = false;
        }
        if (i < path.length) {
          path = path.slice(i);
          if (n.wildChild) {
            n = n.children[0];
            n.priority++;
            if (path.length >= n.path.length && n.path === path.slice(0, n.path.length) && // Adding a child to a catchAll is not possible
            n.type !== 3 /* CATCH_ALL */ && (n.path.length >= path.length || path[n.path.length] === "/")) {
              continue walk;
            } else {
              let pathSeg = path;
              if (n.type !== 3 /* CATCH_ALL */) {
                pathSeg = path.split("/")[0];
              }
              const prefix = fullPath.slice(0, fullPath.indexOf(pathSeg)) + n.path;
              throw new Error(
                `'${pathSeg}' in new path '${fullPath}' conflicts with existing wildcard '${n.path}' in existing prefix '${prefix}'`
              );
            }
          }
          const c = path[0];
          if (n.type === 2 /* PARAM */ && c === "/" && n.children.length === 1) {
            n = n.children[0];
            n.priority++;
            continue walk;
          }
          for (let j = 0; j < n.indices.length; j++) {
            if (c === n.indices[j]) {
              j = n.addPriority(j);
              n = n.children[j];
              continue walk;
            }
          }
          if (c !== ":") {
            n.indices += c;
            const child = new Node("", false, 0 /* STATIC */);
            n.children.push(child);
            n.addPriority(n.indices.length - 1);
            n = child;
          }
          n.insertChild(path, fullPath, handle);
          return;
        }
        if (n.handle !== null) {
          throw new Error("A handle is already registered for path '" + fullPath + "'");
        }
        n.handle = handle;
        return;
      }
  }
  insertChild(path, fullPath, handle) {
    let n = this;
    for (; ; ) {
      let { wildcard, catchall, i, valid } = findWildcard(path);
      if (i < 0) {
        break;
      }
      if (!valid) {
        throw new Error(
          "only one wildcard per path segment is allowed, has: '" + wildcard + "' in path '" + fullPath + "'"
        );
      }
      if (catchall ? wildcard.length < 3 : wildcard.length < 2) {
        throw new Error("wildcards must be named with a non-empty name in path '" + fullPath + "'");
      }
      if (n.children.length > 0) {
        throw new Error("wildcard route '" + wildcard + "' conflicts with existing children in path '" + fullPath + "'");
      }
      if (!catchall) {
        if (i > 0) {
          n.path = path.slice(0, i);
          path = path.slice(i);
        }
        n.wildChild = true;
        const child = new Node(wildcard, false, 2 /* PARAM */);
        n.children = [child];
        n = child;
        n.priority++;
        if (wildcard.length < path.length) {
          path = path.slice(wildcard.length);
          const staticChild = new Node("", false, 0 /* STATIC */, "", [], null, 1);
          n.children = [staticChild];
          n = staticChild;
          continue;
        }
        n.handle = handle;
        return;
      } else {
        if (i + wildcard.length != path.length) {
          throw new Error("catch-all routes are only allowed at the end of the path in path '" + fullPath + "'");
        }
        if (n.path.length > 0 && n.path[n.path.length - 1] === "/") {
          throw new Error(
            "catch-all conflicts with existing handle for the path segment root in path '" + fullPath + "'"
          );
        }
        i--;
        if (path[i] !== "/") {
          throw new Error("no / before catch-all in path '" + fullPath + "'");
        }
        n.path = path.slice(0, i);
        const catchAllChild = new Node("", true, 3 /* CATCH_ALL */);
        n.children = [catchAllChild];
        n.indices = "/";
        n = catchAllChild;
        n.priority++;
        const child = new Node(path.slice(i), false, 3 /* CATCH_ALL */, "", [], handle, 1);
        n.children = [child];
        return;
      }
    }
    n.path = path;
    n.handle = handle;
  }
  search(path) {
    let handle = null;
    const params = {};
    let n = this;
    walk:
      for (; ; ) {
        if (path.length > n.path.length) {
          if (path.slice(0, n.path.length) === n.path) {
            path = path.slice(n.path.length);
            if (!n.wildChild) {
              const c = path.charCodeAt(0);
              for (let i = 0; i < n.indices.length; i++) {
                if (c === n.indices.charCodeAt(i)) {
                  n = n.children[i];
                  continue walk;
                }
              }
              return { handle, params };
            }
            n = n.children[0];
            switch (n.type) {
              case 2 /* PARAM */: {
                let end = 0;
                while (end < path.length && path.charCodeAt(end) !== 47) {
                  end++;
                }
                params[n.path.slice(1)] = path.slice(0, end);
                if (end < path.length) {
                  if (n.children.length > 0) {
                    path = path.slice(end);
                    n = n.children[0];
                    continue walk;
                  }
                  return { handle, params };
                }
                handle = n.handle;
                return { handle, params };
              }
              case 3 /* CATCH_ALL */:
                params[n.path.slice(2, -1)] = path.slice(1);
                handle = n.handle;
                return { handle, params };
              default:
                throw new Error("invalid node type");
            }
          }
        } else if (path === n.path) {
          handle = n.handle;
        }
        return { handle, params };
      }
  }
};

// ../../lib/tree-router/http.ts
var methods = [
  "GET",
  "POST",
  "PUT",
  "DELETE",
  "PATCH",
  "HEAD",
  "OPTIONS",
  "CONNECT",
  "TRACE",
  "LOCK",
  "UNLOCK"
];

// ../../lib/tree-router/route.ts
var Route = class {
  handlers;
  router;
  path;
  constructor(router, path, handlers = []) {
    if (path[0] !== "/") {
      throw new Error("path must begin with '/' in path '" + path + "'");
    }
    if (path[path.length - 1] === "/") {
      path = path.substring(0, path.length - 1);
    }
    this.handlers = [...handlers];
    this.router = router;
    this.path = path;
  }
  subpath(path) {
    if (path[0] !== "/") {
      throw new Error("path must start with a '/'");
    }
    if (path === "/") {
      return this.path;
    }
    return this.path + path;
  }
  route(path) {
    return new Route(this.router, this.subpath(path), this.handlers);
  }
  on(method, path, ...handle) {
    handle.unshift(...this.handlers);
    return this.router.on(method, this.subpath(path), ...handle);
  }
  get(path, ...handle) {
    return this.on("GET", path, ...handle);
  }
  put(path, ...handle) {
    return this.on("PUT", path, ...handle);
  }
  post(path, ...handle) {
    return this.on("POST", path, ...handle);
  }
  delete(path, ...handle) {
    return this.on("DELETE", path, ...handle);
  }
  head(path, ...handle) {
    return this.on("HEAD", path, ...handle);
  }
  patch(path, ...handle) {
    return this.on("PATCH", path, ...handle);
  }
  options(path, ...handle) {
    return this.on("OPTIONS", path, ...handle);
  }
  trace(path, ...handle) {
    return this.on("TRACE", path, ...handle);
  }
  connect(path, ...handle) {
    return this.on("CONNECT", path, ...handle);
  }
  all(path, ...handle) {
    methods.forEach((method) => {
      this.on(method, path, ...handle);
    });
    return this;
  }
  use(...handle) {
    this.handlers.push(...handle);
  }
};

// ../../lib/tree-router/index.ts
var NOT_FOUND = { handle: null, params: {} };
function trimLastSlash(path) {
  if (path.length > 1 && path.charCodeAt(path.length - 1) === 47) {
    return path.slice(0, -1);
  }
  return path;
}
var Router = class {
  handlers;
  trees;
  opts;
  constructor(opts = {}) {
    this.handlers = [];
    this.trees = {};
    this.opts = opts;
  }
  on(method, path, ...handle) {
    if (path[0] !== "/") {
      throw new Error("path must begin with '/' in path");
    }
    handle.unshift(...this.handlers);
    if (!this.trees[method]) {
      this.trees[method] = new Node();
    }
    this.trees[method].addRoute(path, handle);
    return this;
  }
  get(path, ...arg) {
    return this.on("GET", path, ...arg);
  }
  put(path, ...arg) {
    return this.on("PUT", path, ...arg);
  }
  post(path, ...arg) {
    return this.on("POST", path, ...arg);
  }
  delete(path, ...arg) {
    return this.on("DELETE", path, ...arg);
  }
  head(path, ...arg) {
    return this.on("HEAD", path, ...arg);
  }
  patch(path, ...arg) {
    return this.on("PATCH", path, ...arg);
  }
  options(path, ...arg) {
    return this.on("OPTIONS", path, ...arg);
  }
  trace(path, ...arg) {
    return this.on("TRACE", path, ...arg);
  }
  connect(path, ...arg) {
    return this.on("CONNECT", path, ...arg);
  }
  all(path, ...arg) {
    methods.forEach((method) => {
      this.on(method, path, ...arg);
    });
    return this;
  }
  use(...handle) {
    this.handlers.push(...handle);
  }
  find(method, path) {
    const tree = this.trees[method];
    if (tree) {
      if (this.opts.ignoreTrailingSlash) {
        path = trimLastSlash(path);
      }
      return tree.search(path);
    }
    return NOT_FOUND;
  }
  allowedMethods(path) {
    const router = this;
    const allowList = [];
    for (let key in router.trees) {
      const tree = router.trees[key];
      if (tree.search(path).handle !== null) {
        allowList.push(key);
      }
    }
    return allowList;
  }
  route(path) {
    return new Route(this, path, this.handlers);
  }
};

// index.ts
import { http } from "@ampt/sdk";
import { v, compile } from "suretype";
function normalize(path) {
  return path.replace(/^\/*([^\/]+)?\/*$/, "$1").replace(/\/+/g, "/");
}
async function readStream(stream) {
  let result = "";
  for await (const chunk of stream) {
    result += chunk;
  }
  return result;
}
var ApiRequest = class {
  _request;
  _body;
  query;
  url;
  headers;
  constructor(request, url) {
    this._request = request;
    this.url = url;
    this.query = this.url.searchParams;
    this.headers = this._request.headers;
  }
  async body() {
    if (this._body === void 0) {
      if (this._request.body) {
        const text = await readStream(this._request.body);
        this._body = JSON.parse(text);
      } else {
        this._body = null;
      }
    }
    return this._body;
  }
};
var ApiResponse = class {
  status = 200;
  headers = new Headers({
    "Content-Type": "application/json"
  });
  body;
  fetchResponse() {
    return new Response(JSON.stringify(this.body), {
      status: this.status,
      headers: this.headers
    });
  }
};
var HttpEvent = class {
  params;
  request;
  response;
  context;
  constructor(params, request) {
    this.params = params;
    this.request = request;
    this.response = new ApiResponse();
    this.context = {};
  }
  status(status) {
    this.response.status = status;
    return this;
  }
  redirect(url, status = 302) {
    this.response.headers.append("Location", url);
    this.response.status = status;
    return this;
  }
  body(body) {
    this.response.body = body;
    return this;
  }
};
var ApiRouter = class {
  prefix;
  router;
  middleware;
  validate;
  constructor({
    prefix,
    schema,
    middleware
  }) {
    this.prefix = `/${normalize(prefix)}`;
    this.middleware = middleware;
    this.router = new Router();
    this.validate = schema ? compile(v.object(schema), { ajvOptions: { coerceTypes: true } }) : () => ({ ok: true });
  }
  on(method, _route, handler) {
    const normalized = normalize(_route);
    const route = normalized === "" ? "" : `/${normalized}`;
    return this.router.on(method, `${this.prefix}${route}`, handler);
  }
  get(route, handler) {
    return this.on("GET", route, handler);
  }
  post(route, handler) {
    return this.on("POST", route, handler);
  }
  put(route, handler) {
    return this.on("PUT", route, handler);
  }
  patch(route, handler) {
    return this.on("PATCH", route, handler);
  }
  delete(route, handler) {
    return this.on("DELETE", route, handler);
  }
  options(route, handler) {
    return this.on("OPTIONS", route, handler);
  }
  head(route, handler) {
    return this.on("HEAD", route, handler);
  }
};
var Group = class {
  routes = /* @__PURE__ */ new Map();
  router(prefix, schema, ...middleware) {
    const router = new ApiRouter({ prefix, schema, middleware });
    http.use(prefix, async (_fetchRequest) => {
      const url = new URL(_fetchRequest.url);
      const result = router.router.find(_fetchRequest.method, url.pathname);
      if (result?.params) {
        const validationResult = router.validate(result.params);
        if (!validationResult.ok) {
          return new Response(validationResult.explanation, { status: 400 });
        }
      }
      const request = new ApiRequest(_fetchRequest, url);
      const event = new HttpEvent(
        result?.params || {},
        request
      );
      for (const middleware2 of router.middleware) {
        const output = await middleware2(event);
        if (output) {
          return output.response.fetchResponse();
        }
      }
      if (!result.handle) {
        return new Response("Not found", { status: 404 });
      }
      for (const handler of result.handle) {
        const output = await handler(event);
        if (output) {
          return output.response.fetchResponse();
        }
      }
      return new Response("Not found", { status: 404 });
    });
    return router;
  }
};
var Api = class {
  groups;
  constructor() {
    this.groups = /* @__PURE__ */ new Map();
  }
  group(name) {
    if (!this.groups.has(name)) {
      const group = new Group();
      this.groups.set(name, group);
    }
    return this.groups.get(name);
  }
};
var globalApi = new Api();
function api(name) {
  return globalApi.group(name || "default");
}
export {
  ApiRequest,
  ApiResponse,
  HttpEvent,
  api,
  v
};
