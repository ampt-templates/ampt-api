import { Router, HTTPMethod } from '@ampt/tree-router';
export { HTTPMethod } from '@ampt/tree-router';
import { CoreValidator, TypeOf, ValidateFunction } from 'suretype';
export { v } from 'suretype';

type ExtractRouteParams<T extends string> = string extends T ? Record<string, string> : T extends `${infer Start}:${infer Param}*` ? {
    [k in Param]: string;
} : T extends `${infer Start}:${infer Param}/${infer Rest}` ? {
    [k in Param | keyof ExtractRouteParams<Rest>]: string;
} : T extends `${infer Start}:${infer Param}` ? {
    [k in Param]: string;
} : {};
type Params<A, B> = {
    [K in keyof A]: K extends keyof B ? B[K] : A[K];
};
type ObjectSchema = {
    [key: string]: CoreValidator<any>;
};
type SyncOrAsync<T> = T | Promise<T>;
type ApiHandler<Route extends string, RouterParams> = (event: HttpEvent<Params<ExtractRouteParams<Route>, RouterParams>>) => SyncOrAsync<HttpEvent<Params<ExtractRouteParams<Route>, RouterParams>>>;
type MiddlewareHandler<ParamsType> = (event: HttpEvent<ParamsType>) => SyncOrAsync<HttpEvent<ParamsType>>;
declare class ApiRequest {
    private _request;
    private _body;
    query: URLSearchParams;
    url: URL;
    headers: Headers;
    constructor(request: Request, url: URL);
    body(): Promise<any>;
}
declare class ApiResponse {
    status: number;
    headers: Headers;
    body: any;
    fetchResponse(): Response;
}
declare class HttpEvent<ParamsType> {
    params: ParamsType;
    request: ApiRequest;
    response: ApiResponse;
    context: Record<string, any>;
    constructor(params: ParamsType, request: ApiRequest);
    status(status: number): this;
    redirect(url: string, status?: number): this;
    body(body: any): this;
}
declare class ApiRouter<ParamsSchema extends ObjectSchema> {
    prefix: string;
    router: Router;
    middleware: MiddlewareHandler<{
        [key in keyof ParamsSchema]: TypeOf<ParamsSchema[key]>;
    }>[];
    validate: ValidateFunction;
    constructor({ prefix, schema, middleware }: {
        prefix: string;
        schema?: ParamsSchema;
        middleware: MiddlewareHandler<{
            [key in keyof ParamsSchema]: TypeOf<ParamsSchema[key]>;
        }>[];
    });
    on<Route extends string>(method: HTTPMethod, _route: Route, handler: ApiHandler<Route, {
        [key in keyof ParamsSchema]: TypeOf<ParamsSchema[key]>;
    }>): Router;
    get<Route extends string>(route: Route, handler: ApiHandler<Route, {
        [key in keyof ParamsSchema]: TypeOf<ParamsSchema[key]>;
    }>): Router;
    post<Route extends string>(route: Route, handler: ApiHandler<Route, {
        [key in keyof ParamsSchema]: TypeOf<ParamsSchema[key]>;
    }>): Router;
    put<Route extends string>(route: Route, handler: ApiHandler<Route, {
        [key in keyof ParamsSchema]: TypeOf<ParamsSchema[key]>;
    }>): Router;
    patch<Route extends string>(route: Route, handler: ApiHandler<Route, {
        [key in keyof ParamsSchema]: TypeOf<ParamsSchema[key]>;
    }>): Router;
    delete<Route extends string>(route: Route, handler: ApiHandler<Route, {
        [key in keyof ParamsSchema]: TypeOf<ParamsSchema[key]>;
    }>): Router;
    options<Route extends string>(route: Route, handler: ApiHandler<Route, {
        [key in keyof ParamsSchema]: TypeOf<ParamsSchema[key]>;
    }>): Router;
    head<Route extends string>(route: Route, handler: ApiHandler<Route, {
        [key in keyof ParamsSchema]: TypeOf<ParamsSchema[key]>;
    }>): Router;
}
declare class Group {
    routes: Map<string, any>;
    router<ParamsSchema extends ObjectSchema>(prefix: string, schema?: ParamsSchema, ...middleware: MiddlewareHandler<{
        [key in keyof ParamsSchema]: TypeOf<ParamsSchema[key]>;
    }>[]): ApiRouter<ParamsSchema>;
}
declare function api(name?: string): Group;

export { ApiHandler, ApiRequest, ApiResponse, ExtractRouteParams, HttpEvent, MiddlewareHandler, ObjectSchema, Params, SyncOrAsync, api };
